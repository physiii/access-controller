import net from 'net';
import { randomUUID } from 'crypto';
import { config as loadEnv } from 'dotenv';
import { FrameParser, writeFrame } from './protocol.js';

loadEnv();

const TUNNEL_HOST = process.env.MOCK_TUNNEL_HOST ?? process.env.TUNNEL_HOST ?? '127.0.0.1';
const TUNNEL_PORT = parseInt(process.env.MOCK_TUNNEL_PORT ?? process.env.TUNNEL_PORT ?? '9001', 10);
const DEVICE_ID = process.env.MOCK_DEVICE_ID ?? process.env.DEVICE_ID ?? null;

function log(message, extra = {}) {
  const output = { time: new Date().toISOString(), message, ...extra };
  // eslint-disable-next-line no-console
  console.log(JSON.stringify(output));
}

function createConnection() {
  const socket = net.createConnection({ host: TUNNEL_HOST, port: TUNNEL_PORT }, () => {
    log('Mock client connected', { host: TUNNEL_HOST, port: TUNNEL_PORT });
  });

  socket.setNoDelay(true);
  socket.setKeepAlive(true, 15000);

  const parser = new FrameParser({
    onMessage: (header, body) => handleMessage(socket, header, body),
    onError: (err) => {
      log('Protocol error', { error: err.message });
      socket.destroy(err);
    },
  });

  socket.on('data', (chunk) => parser.push(chunk));
  socket.on('close', () => log('Socket closed'));
  socket.on('error', (err) => log('Socket error', { error: err.message }));

  return socket;
}

let activeSocket = createConnection();
let assignedDeviceId = null;

function handleMessage(socket, header, body) {
  switch (header?.type) {
    case 'assign': {
      assignedDeviceId = header.deviceId;
      log('Received assigned device ID', { assignedDeviceId });
      if (DEVICE_ID && DEVICE_ID !== assignedDeviceId) {
        try {
          writeFrame(socket, { type: 'identify', deviceId: DEVICE_ID });
          assignedDeviceId = DEVICE_ID;
          log('Sent IDENTIFY override', { deviceId: DEVICE_ID });
        } catch (err) {
          log('Failed to send IDENTIFY frame', { error: err.message });
        }
      }
      break;
    }
    case 'ready': {
      assignedDeviceId = header.deviceId ?? assignedDeviceId;
      log('Tunnel ready', { deviceId: assignedDeviceId });
      break;
    }
    case 'ping': {
      try {
        writeFrame(socket, { type: 'pong' });
      } catch (err) {
        log('Failed to send PONG', { error: err.message });
      }
      break;
    }
    case 'httpRequest': {
      respondToHttpRequest(socket, header, body);
      break;
    }
    case 'disconnect': {
      log('Server requested disconnect', { reason: header.reason });
      socket.destroy();
      break;
    }
    default: {
      log('Received unhandled message type', { type: header?.type });
    }
  }
}

function respondToHttpRequest(socket, header, body) {
  const {
    requestId,
    method,
    target,
    headers = {},
  } = header;

  if (!requestId) {
    log('Received HTTP request without requestId');
    return;
  }

  const responseBody = Buffer.from(createResponseText({ method, target, headers, body }), 'utf8');

  const responseHeaders = {
    'content-type': ['text/plain; charset=utf-8'],
    'content-length': [String(responseBody.length)],
    'cache-control': ['no-cache, no-store, must-revalidate'],
  };

  try {
    writeFrame(socket, {
      type: 'httpResponse',
      requestId,
      statusCode: 200,
      headers: responseHeaders,
    }, responseBody);
    log('Responded to HTTP request', { requestId, method, target });
  } catch (err) {
    log('Failed to send HTTP response', { requestId, error: err.message });
    try {
      writeFrame(socket, {
        type: 'httpError',
        requestId,
        message: err.message,
      });
    } catch (error) {
      log('Failed to send HTTP error message', { requestId, error: error.message });
    }
  }
}

function createResponseText({ method, target, headers, body }) {
  const lines = [];
  lines.push(`Mock ESP32 tunnel response at ${new Date().toISOString()}`);
  lines.push(`Device ID: ${assignedDeviceId ?? 'unknown'}`);
  lines.push(`Request: ${method} ${target}`);
  lines.push('');
  lines.push('Headers:');
  for (const [key, values] of Object.entries(headers)) {
    lines.push(`  ${key}: ${(Array.isArray(values) ? values : [values]).join(', ')}`);
  }
  lines.push('');
  if (body?.length) {
    const preview = body.length > 512 ? `${body.slice(0, 512).toString('utf8')}â€¦` : body.toString('utf8');
    lines.push('Body preview:');
    lines.push(preview);
  } else {
    lines.push('No request body received.');
  }
  lines.push('');
  lines.push(`Response generated by mock client ${randomUUID().slice(0, 8)}`);
  return lines.join('\n');
}

process.on('SIGINT', () => {
  log('SIGINT received, closing mock client');
  if (activeSocket && !activeSocket.destroyed) {
    activeSocket.destroy();
  }
  process.exit(0);
});

process.on('SIGTERM', () => {
  log('SIGTERM received, closing mock client');
  if (activeSocket && !activeSocket.destroyed) {
    activeSocket.destroy();
  }
  process.exit(0);
});

